CC ?= cc
GREP ?= grep
SED ?= sed
SH ?= sh
WGET ?= wget

# C preprocessor flags
CPPFLAGS ?= -D_FORTIFY_SOURCE=2
# C compiler flags
CFLAGS ?= -O2 -Wall -W -Wextra -ansi -pedantic -pipe \
	-Wmissing-prototypes -Wno-unused-function -Wformat=2 -Wpointer-arith \
	-Winit-self -Wwrite-strings -Wno-shadow \
	-fno-exceptions -fno-stack-protector -fvisibility=hidden
# Linker flags
LDFLAGS ?= -Wl,-z,relro,-z,now,--no-undefined

# Compile without the standard library, and use custom include dir if any
CFLAGS += $(shell [ -d include ] && echo '-I./include')
LDFLAGS += -nostdlib -e _start

# Compile a shared object because there is no need of ld.so on Intel architecture.
# However, some ARM compilers rely on ld.so to remap offsets when doing ASLR, so
# whitelist some known-to-work compilers, such as arm-none-eabi-gcc (bare metal).
ifeq ($(shell $(CC) -E -v - < /dev/null 2>&1 > /dev/null | $(GREP) -qi "^Target.\s*\(x86\|arm-none-\)" && echo y),y)
CFLAGS += -fPIC
LDFLAGS += -fPIC -shared
else
CFLAGS += -fPIE
LDFLAGS += -fPIE -pie
endif

# Files
SOURCES := $(wildcard *.c)
HEADERS := $(wildcard *.h)
OBJECTS :=

# Compile 32-bits versions and 64-bits versions, if available
HAVE_M32_M64 ?= y
ifeq ($(shell $(CC) -m32 -E -v - < /dev/null > /dev/null 2>&1 && echo y),y)
OBJECTS += $(SOURCES:%.c=%.32.o)
else
HAVE_M32_M64 := n
endif
ifeq ($(shell $(CC) -m64 -E -v - < /dev/null > /dev/null 2>&1 && echo y),y)
OBJECTS += $(SOURCES:%.c=%.64.o)
else
HAVE_M32_M64 := n
endif
ifneq ($(HAVE_M32_M64),y)
OBJECTS := $(SOURCES:%.c=%.out.o)
endif

BINARIES := $(OBJECTS:%.o=%)

all: $(BINARIES)

all32: $(SOURCES:%.c=%.32)

all64: $(SOURCES:%.c=%.64)

clean:
	rm -f *.o
	rm -f *.out *.32 *.64

%.out: %.out.o
	$(CC) $(LDFLAGS) -o $@ $^

%.32: %.32.o
	$(CC) $(LDFLAGS) -m32 -o $@ $^

%.64: %.64.o
	$(CC) $(LDFLAGS) -m64 -o $@ $^

%.out.o: %.c $(HEADERS)
	$(CC) $(CFLAGS) $(CPPFLAGS) -c -o $@ $<

%.32.o: %.c $(HEADERS)
	$(CC) $(CFLAGS) $(CPPFLAGS) -m32 -c -o $@ $<

%.64.o: %.c $(HEADERS)
	$(CC) $(CFLAGS) $(CPPFLAGS) -m64 -c -o $@ $<


# Make an "include" directory, when no system header is available
INCLUDE_ARCH := arm i386 x86_64
INCLUDE_ASMDIRS := include/asm $(INCLUDE_ARCH:%=include/asm-%)
INCLUDE_FILES := $(INCLUDE_ASMDIRS:%=%/unistd.h) include/sys/utsname.h
LINUX_URL := https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain

create_include: $(INCLUDE_FILES)

include/asm/unistd.h: Makefile
	[ -d $(@D) ] || mkdir -p $(@D)
	echo '/* THIS FILE IS AUTOMATICALLY GENERATED BY Makefile */' > $@
	echo '/* Include the arch-specific unistd.h file */' >> $@
	echo '#if defined __arm__' >> $@
	echo '#include "../asm-arm/$(@F)"' >> $@
	echo '#elif defined __i386__' >> $@
	echo '#include "../asm-i386/$(@F)"' >> $@
	echo '#elif defined __x86_64__' >> $@
	echo '#include "../asm-x86_64/$(@F)"' >> $@
	echo '#endif' >> $@

# Download ARM kernel header
include/asm-arm/unistd.h:
	[ -d $(@D) ] || mkdir -p $(@D)
	$(WGET) -q -O $@ $(LINUX_URL)/arch/$(@D:include/asm-%=%)/include/uapi/asm/$(@F) || (rm $@ ; false)

# Build x86 syscall tables using script "syscallhdr.sh" from the kernel
include/syscall-x86/%:
	[ -d $(@D) ] || mkdir -p $(@D)
	$(WGET) -q -O $@ $(LINUX_URL)/arch/x86/syscalls/$(@F) || (rm $@ ; false)

include/asm-i386/unistd.h: include/syscall-x86/syscall_32.tbl include/syscall-x86/syscallhdr.sh
	[ -d $(@D) ] || mkdir -p $(@D)
	$(SH) include/syscall-x86/syscallhdr.sh '$<' '$@' 'common,i386' '' ''

include/asm-x86_64/unistd.h: include/syscall-x86/syscall_64.tbl include/syscall-x86/syscallhdr.sh
	[ -d $(@D) ] || mkdir -p $(@D)
	$(SH) include/syscall-x86/syscallhdr.sh '$<' '$@' 'common,64' '' ''

# Build sys/utsname.h file from linux/utsname.h kernel header
include/sys/linux_utsname.h:
	[ -d $(@D) ] || mkdir -p $(@D)
	$(WGET) -q -O $@ $(LINUX_URL)/include/uapi/linux/utsname.h || (rm $@ ; false)

include/sys/utsname.h: include/sys/linux_utsname.h
	$(SED) 's/struct new_utsname/struct utsname/' < $< > $@

.PHONY: all all32 all64 clean create_include
